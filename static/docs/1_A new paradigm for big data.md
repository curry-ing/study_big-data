# 1. 빅데이터를 위한 새로운 패러다임
> **GOAL**      
- 전통적인 데이터베이스를 확장장시 발생하는 문제  
- NoSQL이 만병통치약은 아니다 
- 빅데이터 시스템의 기본 원칙
- 빅데이터 처리 도구의 분야 
- `SuperWebAnalytics.com` 소개 

요즈음 데이터의 특징: 양 & 종류 양쪽으로 폭발적으로 증가  
확장성에 문제발생 -> RDB와 같은 전통적 DBMS의 한계  

##### 확장성 (scalability)
- 이를 해결하기 위한 수많은 대안이 등장
- 분산 파일 시스템, 맵리듀스, 분산 잠금 서비스, Hadoop, MongoDB, Cassandra, RabbitMQ 등…

##### 복잡성 (complexity)
- 전통적인 RDBMS는 확장성 못지않게 **복잡성**도 문제가 됨 
- 이런 복잡성을 단순화하기 위한 대안 패러다임: **람다 아키텍쳐**


## 1.1 이 책의 구성 
- 이론과 실제로 구성됨미다 


## 1.2 전통적이 데이터베이스의 확장 
### 1.2.0 문제가 되는 상황 
- 예시 > 페이지뷰를 한 번 할 때마다 로그 테이블의 페이지뷰 값을 1씩 증가
- 그런데 서비스가 예상외로 너무 잘 되어서 페이지뷰가 폭발적으로 증가하게 되고…

### 1.2.1 해결책 1: Queue
- 건당 1개의 업데이트는 DBMS에서 병목현상을 불러 일으키기에, 이를 효과적으로 모아서 `chunk`단위로 묶어 처리하는 idea
- DBMS 병목 현상은 어느정도 해소
- DB의 capacity는 정해져 있기 때문에 일정 수준이 넘어가는 순간 문제는 다시 발생 

### 1.2.2 해결책 2: 데이터베이스 샤딩 
- DBMS를 분리하자는 idea 
- 수평 분할(horizontal partitioning), 샤딩(shading)

##### 샤딩의 한계
- 초기 샤딩작업에 기본적으로 자원이 소모 (다운타임 발생)
- 어플리케이션에 샤딩을 위한 로직이 추가됨 
- 부하가 계속 늘어나는 경우 발생
- 샤딩이 복잡해질 경우 개발자가 신경 쓸 부분 증가: 버그 초래 

### 1.2.3 내결함성 문제가 발생 
내결함성 문제란 : 시스템의 물리적 장애등으로 인한 장애상황 

> **예**: 운용중인 서버의 디스크 장애 발생    
**상황**: 해결 전까지 디스크 사용 불가: 데이터 읽기/쓰기 문제    
**해결책**    
	1. 사용 불능 상태의 샤드로 데이터가 오면 *대기 큐*등에 적재    
	2. Slave DB를 read-only로 세팅(쓰지는 못해도 읽을 순 있게)    
 
### 1.2.4 데이터 오염
- 엎친데 덮친 격으로 버그가 있는 코드가 배포되어 데이터 오염 
- 히스토리가 없이 결과만 update된 경우 (증분식) 어찌 할 도리가 없다

### 1.2.5 어디부터 잘못된 거지? 
- 문제1: DBMS는 스스로 데이터가 어떤 원리로 분산되어 있는지 알 지 못함: **샤딩과 관련된 소프트웨어적 부담은 모두 사람의 몫**
- 문제2: 사람이 실수하면 방법이 없다  
-> 좋은 시스템: 사람의 실수로 발생하는 손실을 제한(인적 내결함성 확보) 할 수 있도록 강건하게 설계된 시스템 

### 1.2.6 빅데이터 기술이 어떻게 도움이 될 수 있을까?
- 시스템이 스스로 분산에 대한 정보를 들고 있다: 1.2.5에서 언급한 것처럼 분산에 대한 고려가 개발자의 몫이 아닌게 됨으로써 로직에 집중 
- immutable 권장: 결과가 아닌 계보를 저장: `tb_cash`, `tb_point` 등이 좋은 예(?)
- 빅데이터 기술은 더 거대한 데이터를 다룰 수 있는 확장성을 제공: 시스템을 근본적으로 다른 방식으로 설계 가능 


## 1.3 NoSQL은 만병 통치약이 아니다 
- 전통적인 DBMS보다 훨씬 제한된 모델 제공 (반대급부로 확장성을 얻음)
	- 이런 제한된 데이터 모델로 인해 어플리케이션이 더 복잡해 질 **우려**
- 가변성을 전제로 하기 때문에 인적 내결함성에 대한 **우려**

그럼에도 불구하고, 이들을 현명하게 잘 결합하면...  
**인적 내결함성**을 갖추고, **복잡성을 최소화** 하며, **확장성**있는 좋은 시스템을 구축할 수 있다: 그거시 **`Lambda Architecture`**


## 1.4 기본 원칙 
- 데이터 시스템의 근본 역할: 쌓인 정보에 의거해서 질의에 응답 
	- 여러 조각 정보를 융합하여 응답을 만들어 내기도 한다 
	- 모든 정보의 조각이 동등한 레벨은 아니다: 원자 정보(**`data`**), 집계 정보, 융합 정보 등 
- 데이터 시스템이란 간단히… `query = function(all data)`


> **람다 아키텍쳐**    
- 임의의 데이터 집합을 가지고,  
- 수행되는 임의의 함수를 구현하고,  
- 함수의 결과를 빠른 지연시간 안에 반환하게 만드는 일반적인 용도의 접근법  


## 1.5 빅데이터 시스템에 요구되는 특성 
확장성과 복잡성에 관련된 사항들 

- **견고함과 내결함성**
- **짧은 읽기/갱신 지연시간**
- **확장성**(scalability): 부하 증가시 시스템 자원의 투입만으로 원래의 성능을 유지할 수 있는 능력
- **일반성**(generalization): 폭넓은 분야의 애플리케이션에 활용 가능 
- **유연성**(extensibility): 최소한의 유지보수 비용으로 기능의 추가/변경/제거 등이 가능 
- **즉석질의**(ad-hoc query)
- **최소한의 유지보수**
	- *구현 복잡도*를 낮게(단순한 알고리즘, 단순한 구성 요소)
	- `lambda-arch`: 핵심 구성요소에서 복잡한 부분은 따로 분리하여 시스템의 다른 영역에 고립
- **디버깅 가능성** 
	- 시스템에 존재하는 각 값들이 그렇게 된 이유를 정확히 추적할 수 있을까? 
	- `lambda-arch`: batch-layer의 기능적인 특성 + 필요시 재계산 알고리즘 


## 1.6 완전 증분 아키텍처의 문제점 
Application <--> Database

- 완전 증분 아키텍쳐는 매우 복잡하지만, 이 복잡함에 개발자들은 이미 너무 익숙해져 있다(familia complexity)
* 복잡성을 타개하는 방법?: 개중에 Best vs **람다 아키텍쳐**

### 1.6.1 운영 복잡성 
#### 압밀화(compaction)
- 인덱싱 등으로 인한 파편화된 공간, 미사용 인덱스 등을 정리하는 작업(인덱스 재구축)
* 비용이 커서 실시간으로 하기는 힘들고, 일정을 정해서 수행: 서비스 중단이나 노드별 성능 저하를 피할 수 없음 

> 압밀화를 잘 관리하려고 고민하기 보다, 화 자체가 필요 없도록 아키텍쳐를 구성할 수 없을까? -> **람다 아키텍쳐**

### 1.6.2 최종적 일관성을 달성할 때 수반되는 극심한 복잡성
#### 고가용성 vs 일관성
- [CAP 이론](http://www.julianbrowne.com/article/viewer/brewers-cap-theorem): 네트워크가 분단된 상황에서 같은 시스템 내 고가용성과 일관성을 동시에 달성할 수 없음 
- 고가용성 시스템에서는 네트워크 분단이 발생한 동안 오래된 결과를 반환하는 케이스 발생
- 이를 둘 다 만족스러운 수준으로 달성하기 위해서는 어플리케이션 수준에서 엄청난 양의 복잡성이 증대  

##### 단편적인며 간단한 예
1. 두 대의 HA서버에 `10`이 저장되어 있음
2. 네트워크 단절 
3. `+2`, `+1`의 작업이 들어오는데 1번, 2번 서버에 따로 들어옴
4. 1번 서버는 `12` , 2번 서버는 `11`의 값을 가진채로 네트워크 복구
5. 이 상태에서 정상 값인 `13`을 유추할 수 있을까?

### 1.6.3 인적 내결함성 결여 
**사람의 실수는 필연적**
- 결과만을 저장하여 업데이트 하는 경우에는 사람의 실수를 복구하기가 매우 까다롭다 
* 이벤트 로그를 모두 저장한다면, 실수가 발생한 요인을 찾아 선택적으로 복구 가능: **람다 아키텍처의 핵심**

### 1.6.4 완전 증분식 vs 람다 아키텍처 
```scala
uniquesOverTime(url: String, startHour: Int, endHour: Int): Double
```
-> 동일한 사용자가 두 개의 서로 다른 ID를 사용하는 경우, 동일한 유저인지를 판단해 순 방문자수 집계 
- 두 개의 ID를 사용하여 특정 시간 범위 내 하나의 URL을 방문했을 경우 순 방문자수 판단등이 어려움 
- 이와 같은 상황에서 accuracy, latency, throughput 그리고 하드웨어에 발생하는 비용 등 여러 측면에서 **람다 아키텍처**가 훨씬 나은 지표를 보인다 


### 1.7.1 Batch Layer
#### 임무
1. 불변성을 지니며 증가만 하는 마스터 데이터 집합을 저장
2. 그 데이터 집합에 대해 임의의 함수를 계산 

일괄처리 계층을 단순화 한 수도 코드 
```
function runBatchLayer():
	while(true):
		recomputeBatchViews()
```

#### 특징
- 사용이 매우 간단
- 싱글스레드 프로그램과 유사하여 **병렬화 용이**
- 견고하고 확장성이 좋은 계산을 구현하기 쉽다 

### 1.7.2 Serving Layer
일괄처리 뷰를 로딩하여 무작위 읽기를 수행할 수 있도록 하는 특수한 분산 데이터베이스

#### 임무
일괄처리 뷰가 질의에 사용될 수 있도록 로딩 

#### 특징
- 일괄 갱신과 무작위 읽기를 모두 지원
- 무작위 쓰기는 지원하지 않음
	- 무작위 쓰기는 데이터베이스의 복잡성 유발 
	- 단순화에 큰 기여: 견고함, 예측 가능함, 설정 및 운영 용이

### 1.7.3 Batch and Serving Layer satisfy almost all properties
- 일괄처리 계층과 서빙 계층은 ~실시간성~을 제외하면 1.5장의 빅데이터 시스템의 요구 속성을 대부분 만족한다 (`견고성과 내결함성`, `확장성`, `일반성`, `유연성`, `즉석 질의`, `유지보수 용이`, `디버깅 가능`) 
- 낮은 갱신 지연시간(실시간성)은 속도 계층에서 해결

### 1.7.4 Speed Layer
#### 임무
일괄처리 계층에서 커버하지 못한 최근 몇 시간 동안의 데이터를 보완

#### 특징 (특히 `batch layer`와 비교)
- Batch Layer는 전체 데이터를 대상으로 한다면 Speed Layer는 최근 데이터만 대상으로 함
- 지연시간을 최소화 하기 위하여 새로운 데이터 뭉치를 분할하여 처리 
- 뷰를 처음부터 만드는 대신 새로운 데이터를 받을 때 마다 실시간 뷰(realtime view)를 갱신
```
batch view = function(all data)
realtime view = function(realtime view, new data)
query = function(batch view, realtime view)
```

##### 복잡성 고립(complexity isolation)
- 무작위 쓰기를 지원하지 않는 일괄처리 계층과 달리 속도 계층은 무작위 쓰기를 지원하는 데이터베이스를 사용 (서빙 계층보다 구현과 운용의 복잡성 증대)
- 속도 계층의 처리 결과는 일시적으로 쓰이고, 일괄처리 계층에서 따라잡게 되면 버려짐 
- 일시적으로 쓰이고 마는 계층에만 복잡성이 가해짐: **복잡성 고립**

##### 속도와 정확도의 적절한 타협
정확한 결과를 얻는 알고리즘(일괄처리 계층) + 근사 알고리즘(속도 계층)



## 1.8 최근의 기술 동향
### 1.8.1 더 이상 빨라지지 않는 CPU
단일 CPU의 속도는 한계에 도달 : 병렬화를 통한 속도 개선 
-> 비공유 병렬 알고리즘, 맵리듀스 

### 1.8.2 신축적 클라우드 
- `IAAS`의 보급 -> 필요시 자원을 빌려 대량 계산 후 반납  
####  Spot Instance in AWS
- 경매 방식의 자원 할당: 저렴하지만 누군가 나보다 비싸게 부르면 자원을 빼앗김 
- 맵리듀스와 같은 분산 시스템은 소프트웨어 계층에서 내결함성을 지원하므로 유용 

### 1.8.3 빅데이터를 위한 오픈소스 생태계의 활성화 
- **일괄 계산 시스템**: **하둡(HDFS, Map-Reduce)**
	- 어떤 유형이든 다 처리할 수 있지만, 실행 시간이 느릴 수 있다 
	- HDFS: PB 단위의 데이터를 처리할 수 있도록 확장 가능한 분산 저장소 시스템
	- Map-reduce: HDFS와 통합된 수평 확장이 가능한 계산 프레임워크
- **직렬화 프레임워크**: Thrift, Protocol Buffers, **Avro**
	- 서로 다른 언어 사이에서 객체를 사용할 수 있도록 함
- **Random access NoSQL DB**: **Cassandra**, HBase, MongoDB, Voldemort, Riak, CouchDB…
	- SQL의 풍부한 표현력 대신 각각 특정 종류의 연산에 특화
	- 아무데나 가능한 웨어하우징용이 **아니다**
	- 프로그램에서 사용할 자료구조 선택과 비슷: Vector? HashMap? SortedMap? LinkedList?
- **메시징/큐잉 시스템**: **Kafka**, flume, RabbitMQ
	- 내결함성을 갖추고 비동기 처리를 위한 메시징 기능 제공 
- **실시간 계산 시스템**: **Storm**, Spark streaming
	- 일괄처리 시스템 만큼의 계산은 불가능하지만, 메시지를 극도로 빠르게 처리 


## 1.9 예제 어플리케이션: `SuperWebAnalytics.com`
- Minimal GA 지향: 지표의 실시간 제공, Count, 방문자들의 웹사이트 이동 경향 분석 
- 데이터를 저장하고 가고앟여 어플리케이션에 질의 기능을 제공하는 계층 
- 다음 항목들을 제공 
	- 시간대별 페이지뷰
	- 시간대별 순방문자
	- 이탈률 분석 


## 1.10 Summary
#### 공부한 것
- 기존 RDBMS의 한계: 확장(샤딩 등)시 문제 발생
- 람다 아키텍처의 장점
	- 확장성: 데이터의 가치가 증대
	- 견고성
	- 성능 예측 용이(없어? 붙여!) 
	
#### 공부할 것
- 람다 아키텍처의 구축: 데이터의 모델링, 스키마화
